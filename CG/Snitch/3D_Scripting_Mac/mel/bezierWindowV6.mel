/* This file downloaded from Highend3d.com
''  
''  Highend3d.com File Information:
''  
''    Script Name: Bezier Curve / Tube Generator
''    Author:  
''    Last Updated: May 01, 2008
''    Update/Change this file at:
''    http://Highend3d.com/maya/downloads/mel_scripts/modeling/curve_tools/5197.html
''  
''  Please do not alter any information above this line
''  it is generated dynamically by Highend3d.com and will
''  be changed automatically on any updates.
*/
////////////////////////////////////////// Bezier Curve/Tube Generator V6     //// Kevin Edzenga                      //// trancor@metal-asylum.net           ////                                    //// Launch Window using command -      //// bezierWindow;                      //////////////////////////////////////////global proc bezierWindow(){	global int $bezierCount;	global string $bezierWindowCntrlName;	int $curBezSystem=$bezierCount;	float $rand=int(rand(64));	if(`window -exists $bezierWindowCntrlName`){		deleteUI -window $bezierWindowCntrlName;	}	$bezierWindowCntrlName=`window -title "Bezier Controller Window"`;	columnLayout ;			text -l "Currently Editing Bezier System -";			intField -v $bezierCount "bezierSystemNumber";			button -l "Go To Next System" -c "int $sysNumber=`intField -q -v bezierSystemNumber`; $sysNumber=$sysNumber+1; if($sysNumber>$bezierCount){$sysNumber=1;}else if($bezierCount==0){$sysNumber=$bezierCount;}intField -e -v $sysNumber bezierSystemNumber";			button -l "Reset Number System" -c "global int $bezierCount; intField -e -v 0 bezierSystemNumber; $bezierCount=0;";			text -l "";			text -l "Devisions around axis-";			intSlider -dc "text -e -l `intSlider -q -v axisDivSlider` axisDev;" -cc "text -e -l `intSlider -q -v axisDivSlider` axisDev;"  -min 3 -max 100 -v 10   "axisDivSlider";			text -l `intSlider -q -v axisDivSlider` axisDev;			text -l "";			text -l "Devisions on tube-";			intSlider -dc "text -e -l `intSlider -q -v tubeDivSlider` tubeDev;" -cc "text -e -l `intSlider -q -v tubeDivSlider` tubeDev;"  -min 3 -max 100 -v 15  "tubeDivSlider";			text -l `intSlider -q -v axisDivSlider` tubeDev;			text -l "";			text -l "Diameter of tube-";			floatSlider  -dc "text -e -l `floatSlider -q -v tubeDiaSlider` tubeDia;" -cc "text -e -l `floatSlider -q -v tubeDiaSlider` tubeDia;"  -min .01 -max 10 -v 1  "tubeDiaSlider";			text -l `floatSlider -q -v tubeDiaSlider` "tubeDia";			text -l "";			text -l "Control Points on tube-";			intSlider -dc "text -e -l `intSlider -q -v tubeCPntsSlider` tubeCPnts;" -cc "text -e -l `intSlider -q -v tubeCPntsSlider` tubeCPnts;"  -min 2 -max 30 -v 4  "tubeCPntsSlider";			text -l `intSlider -q -v tubeCPntsSlider` tubeCPnts;			text -l "";			text -l "Controller Group Color";			colorIndexSliderGrp -min 0 -max 64 -value $rand colorIndex;			text -l "";			button -l "Create Bezier Tube" -c "makeBezier(`intSlider -q -v axisDivSlider`, `intSlider -q -v tubeDivSlider`, `floatSlider -q -v tubeDiaSlider`, `intSlider -q -v tubeCPntsSlider`, `colorIndexSliderGrp -q -v colorIndex`);int $rand=rand(64); colorIndexSliderGrp -e -v $rand colorIndex; intField -e -v $bezierCount bezierSystemNumber;";			text -l "";			button -l "Update Current Tube System" -c "updateBezierTube(`intField -q -v bezierSystemNumber`)";			text -l "";			button -l "Close Window" -c "deleteUI -window $bezierWindowCntrlName;";	setParent..;	showWindow $bezierWindowCntrlName;}// MultiPointglobal proc makeBezier(int $subAxis, int $subHeight, float $diameter, int $pointControls, int $grpColor){	global int $bezierCount;	$bezierCount=$bezierCount+1;	int $startNumber=$subAxis * ($subHeight);	string $group=`group -w -r -em -n ("bezierCurve"+$bezierCount+"Overlord")`;	string $tube[]=`polyCylinder -r $diameter -h ($subHeight-1) -sx $subAxis -sy ($subHeight-1) -sz 0 -ax 0 1 0 -rcp 0 -cuv 3 -ch 1 -n ("bezier"+$bezierCount+"Tube")`;	parent $tube[0] $group;	if (($subHeight%2) == 1){		move -a 0 (($subHeight/2)) 0 $tube[0];	}else{		move -a 0 (($subHeight/2)-.5) 0 $tube[0];	}	move -a 0 0 0 ($tube[0]+".scalePivot") ($tube[0]+".rotatePivot") ;	rotate -a 0 0 -90 $tube[0];	string $clusterTmp[];	string $clusters[]={};	int $size; 	for($x=0; $x<=$subHeight; ++$x){		if($x != $subHeight){			select -r ($tube[0]+".vtx["+($subAxis*$x)+":"+(($subAxis*($x+1))-1)+"]");			$clusterTmp=`cluster -n ("bezier"+$bezierCount+"Cluster")`;			$size=size($clusters);			$clusters[$size]=$clusterTmp[0];		}	}		string $curvePoints="";	string $circleCntrl[];	string $cntrlGroup;	for ($x=0; $x<=($subHeight-1); ++$x){		$curvePoints=($curvePoints+" -p "+$x+" 0 0");		$circleCntrl=`circle -c 0 0 0 -nr 90 0 0 -sw 360 -r 1.5 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1 -n ("bezier"+$bezierCount+"Control"+($x+1))`;		$cntrlGroup=`group -p $group -n ("bezier"+$bezierCount+"Control"+($x+1)+"Group") $circleCntrl[0]`;		move -a $x 0 0 $cntrlGroup;		xform -cp $circleCntrl[0];		xform -cp $cntrlGroup;		setAttr -keyable false ($cntrlGroup+".tx");		setAttr -keyable false ($cntrlGroup+".ty");		setAttr -keyable false ($cntrlGroup+".tz");		setAttr -keyable false ($cntrlGroup+".rx");		setAttr -keyable false ($cntrlGroup+".ry");		setAttr -keyable false ($cntrlGroup+".rz");		parent ($clusters[$x]+"Handle") $circleCntrl[0];		setAttr (($clusters[$x]+"Handle")+".visibility") 0;	}	for ($x=0; $x<=($subHeight-1); ++$x){		if(($x == 0) || ($x>=($subHeight)) ){			aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 1 0 0 ("bezier"+$bezierCount+"Control"+($x+2)+"Group") ("bezier"+$bezierCount+"Control"+($x+1)+"Group") ;			aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 1 0 0 ("bezier"+$bezierCount+"Control"+($subHeight-1)+"Group") ("bezier"+$bezierCount+"Control"+($subHeight)+"Group") ;		}else{				aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 1 0 0 ("bezier"+$bezierCount+"Control"+($x+1)+"Group") ("bezier"+$bezierCount+"Control"+($x)+"Group") ;		}	}	string $curve;	eval("$curve=`curve -d 2 "+$curvePoints+" -n bezier"+$bezierCount+"CurveBase `");	parent ("bezier"+$bezierCount+"CurveBase") $group;		string $xCurve[];	string $yCurve[];	string $zCurve[];	string $detachX[];	string $detachY[];	string $detachZ[];	string $attach1[];	string $attach2[];	string $attach1[];	string $bezierControlName; 	string $locStart[];	float $math;	for($x=0; $x<$pointControls; ++$x){		$xCurve=`circle -c 0 0 0 -nr 1 0 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0`;		$yCurve=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0`;		$zCurve=`circle -c 0 0 0 -nr 0 0 1 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0`;		$detachX=`detachCurve -ch 0 -cos on -rpo 1 ($xCurve[0]+".u[0]") ($xCurve[0]+".u[2]") `;		$detachY=`detachCurve -ch 0 -cos on -rpo 1 ($yCurve[0]+".u[4]") `;		$detachZ=`detachCurve -ch 0 -cos on -rpo 1 ($zCurve[0]+".u[8]") `;		$attach1=`attachCurve  -ch 0 -rpo 1 -kmk 1 -m 0 -bb 0.5 -bki 0 -p 0.1 -n "attachedCurve" ($detachX[0]+".u[4]") ($detachY[0]+".u[0]") `;		delete $yCurve;		$attach2=`attachCurve  -ch 0 -rpo 1 -kmk 1 -m 0 -bb 0.5 -bki 0 -p 0.1 ($detachX[1]+".u[4]") ($attach1[0]+".u[14]") `;		delete $attach1[0];		$attach1=`attachCurve  -ch 0 -rpo 1 -kmk 1 -m 0 -bb 0.5 -bki 0 -p 0.1 ($zCurve[0]+".u[0]") ($attach2[0]+".u[0]") `;		delete $xCurve;		$bezierControlName=`rename $zCurve ("bezierHandle"+$bezierCount+"Control"+($x+1))`; 		$locStart=`spaceLocator -n ("bezierHandle"+$bezierCount+"Center"+($x+1))`;		setAttr -lock true -keyable false ($locStart[0]+".tx");		setAttr -lock true -keyable false ($locStart[0]+".ty");		setAttr -lock true -keyable false ($locStart[0]+".tz");		setAttr -lock true -keyable false ($locStart[0]+".rx");		setAttr -lock true -keyable false ($locStart[0]+".ry");		setAttr -lock true -keyable false ($locStart[0]+".rz");		setAttr -lock true -keyable false ($locStart[0]+".sx");		setAttr -lock true -keyable false ($locStart[0]+".sy");		setAttr -lock true -keyable false ($locStart[0]+".sz");		setAttr -lock true -keyable false ($locStart[0]+".v");		parent $locStart[0] $bezierControlName;		parent $bezierControlName $group;		$math=($x)*100/($pointControls-1);		$math=($math/100)*($subHeight-1);		move -a $math 0 0 $bezierControlName;	}			string $startBez[];	string $endBez[];	float $tempMath;		for($x=0; $x<$pointControls; ++$x){		if($x!=($pointControls-1)){			$startBez=`spaceLocator -n ("start"+$bezierCount+"Bez"+($x+1))`;			parent $startBez[0] ("bezierHandle"+$bezierCount+"Center"+($x+1));			$math=(float($subHeight)-1)/float($pointControls);			$tempMath=(($x))*100/(float($pointControls)-1);			$tempMath=($tempMath/100)*(float($subHeight)-1);			$tempMath=($tempMath+($math/4));			move -a $tempMath 2.5 0 $startBez[0];			$endBez=`spaceLocator -n ("end"+$bezierCount+"Bez"+($x+1))`;			parent $endBez[0] ("bezierHandle"+$bezierCount+"Center"+($x+2));			$tempMath=(($x+1))*100/(float($pointControls)-1);			$tempMath=($tempMath/100)*(float($subHeight)-1);			$tempMath=($tempMath-($math/4));			move -a $tempMath -2.5 0 $endBez[0];		}else{		}	}	setAttr -lock true ($tube[0]+".tx");	setAttr -lock true ($tube[0]+".ty");	setAttr -lock true ($tube[0]+".tz");	setAttr -lock true ($tube[0]+".rx");	setAttr -lock true ($tube[0]+".ry");	setAttr -lock true ($tube[0]+".rz");	setAttr -lock true ($tube[0]+".sx");	setAttr -lock true ($tube[0]+".sy");	setAttr -lock true ($tube[0]+".sz");	setAttr -lock true ("bezier"+$bezierCount+"CurveBase.tx");	setAttr -lock true ("bezier"+$bezierCount+"CurveBase.ty");	setAttr -lock true ("bezier"+$bezierCount+"CurveBase.tz");	setAttr -lock true ("bezier"+$bezierCount+"CurveBase.rx");	setAttr -lock true ("bezier"+$bezierCount+"CurveBase.ry");	setAttr -lock true ("bezier"+$bezierCount+"CurveBase.rz");	setAttr -lock true ("bezier"+$bezierCount+"CurveBase.sx");	setAttr -lock true ("bezier"+$bezierCount+"CurveBase.sy");	setAttr -lock true ("bezier"+$bezierCount+"CurveBase.sz");			// Expression	expression -s ("\tvector $start;\n\tvector $end;\n\tvector $startBezier;\n\tvector $endBezier;\n\tstring $controllers[];\n\tvector $hermitePoint;\n\tfloat $val;\n\tfloat $min;\n\tfloat $max;\n\t\t$controllers=`ls -type \"transform\" (\"bezier"+$bezierCount+"Control*Group\")`;\n\t\t$curvePointHandles=`ls -type \"transform\" (\"bezierHandle"+$bezierCount+"Control*\")`;\n\t\tfor($x=0; $x<(size($controllers)); ++$x){\n\t\t\t$val=float($x*100);\n\t\t\t$val=$val/(float(size($controllers)-1)/float(size($curvePointHandles)-1));\n\t\t\t$val=($val/100);\n\t\t\tif( (($val%1)==(0)) || (($val)>=(size($curvePointHandles))) ){\n\t\t\t\t$hermitePoint=`xform -q -ws -rp (\"bezierHandle"+$bezierCount+"Control\"+($val+1))`;\n\t\t\t}else{\n\t\t\t\t$min=`min (floor($val)+1) (size($curvePointHandles))`;\n\t\t\t\t$max=`min (ceil($val)+1) (size($curvePointHandles))`;\n\t\t\t\t$start=`xform -q -ws -rp (\"bezierHandle"+$bezierCount+"Control\"+$min)`;\n\t\t\t\t$end=`xform -q -ws -rp (\"bezierHandle"+$bezierCount+"Control\"+$max)`;\n\t\t\t\t$min=`min (floor($val)+1) (size($curvePointHandles)-1)`;\n\t\t\t\t$startBezier=`xform -q -ws -rp (\"start"+$bezierCount+"Bez\"+$min)`;\n\t\t\t\t$max=`min (ceil($val)) (size($curvePointHandles)-1)`;\n\t\t\t\t$endBezier=`xform -q -ws -rp (\"end"+$bezierCount+"Bez\"+$max)`;\n\t\t\t\t$endBezier=<< ((-$endBezier.x)), ((-$endBezier.y)), ((-$endBezier.z))>>;\n\t\t\t\t$val=$val-(floor($val));\n\t\t\t\t$hermitePoint=hermite($start, $end, ($startBezier-$start), ($endBezier+$end), $val);\n\t\t\t}\n\t\t\tsetAttr (\"bezier"+$bezierCount+"Control\"+($x+1)+\"Group.translateX\") ($hermitePoint.x);\n\t\t\tsetAttr (\"bezier"+$bezierCount+"Control\"+($x+1)+\"Group.translateY\") ($hermitePoint.y);\n\t\t\tsetAttr (\"bezier"+$bezierCount+"Control\"+($x+1)+\"Group.translateZ\") ($hermitePoint.z);\n\t\tmove -a ($hermitePoint.x) ($hermitePoint.y) ($hermitePoint.z) (\"bezier"+$bezierCount+"CurveBase.cv[\"+$x+\"]\");\n\t\t}\n")  -o "" -ae 1 -uc all -n ("bezier"+$bezierCount+"Expression") ;					// Place Contrls Script	// Update Bezier Script		vector $start;	vector $end;	vector $startBezier;	vector $endBezier;	string $controllers[];	string $controllers[];	vector $hermitePoint;	float $val;	float $min;	float $max;		$controllers=`ls -type "transform" ("bezier"+$bezierCount+"Control*Group")`;		$curvePointHandles=`ls -type "transform" ("bezierHandle"+$bezierCount+"Control*")`;// Layer Creation		createDisplayLayer -name ("bezier"+$bezierCount+"ControllersLayer") -empty;		createDisplayLayer -name ("bezier"+$bezierCount+"TubeCntrlsLayer") -empty;		setAttr ("bezier"+$bezierCount+"TubeCntrlsLayer.displayType") 1;		setAttr ("bezier"+$bezierCount+"ControllersLayer.color") $grpColor;		setAttr ("bezier"+$bezierCount+"TubeCntrlsLayer.color") $grpColor;		editDisplayLayerMembers -noRecurse ("bezier"+$bezierCount+"ControllersLayer") $controllers;		editDisplayLayerMembers -noRecurse ("bezier"+$bezierCount+"ControllersLayer") $curvePointHandles;		editDisplayLayerMembers -noRecurse ("bezier"+$bezierCount+"ControllersLayer") ("bezier"+$bezierCount+"CurveBase");		select -r `ls -type "transform" ("bezier"+$bezierCount+"Control*")`;		select -tgl `ls -type "transform" ("bezier"+$bezierCount+"Control*Group")`;		editDisplayLayerMembers -noRecurse ("bezier"+$bezierCount+"TubeCntrlsLayer") `ls -sl`;		for($x=0; $x<(size($controllers)); ++$x){			$val=float($x*100);			$val=$val/(float(size($controllers)-1)/float(size($curvePointHandles)-1));			$val=($val/100);			if( (($val%1)==(0)) || (($val)>=(size($curvePointHandles))) ){				$hermitePoint=`xform -q -ws -rp ("bezierHandle"+$bezierCount+"Control"+($val+1))`;			}else{				$min=`min (floor($val)+1) (size($curvePointHandles))`;				$max=`min (ceil($val)+1) (size($curvePointHandles))`;				$start=`xform -q -ws -rp ("bezierHandle"+$bezierCount+"Control"+$min)`;					$end=`xform -q -ws -rp ("bezierHandle"+$bezierCount+"Control"+$max)`;				$min=`min (floor($val)+1) (size($curvePointHandles)-1)`;				$startBezier=`xform -q -ws -rp ("start"+$bezierCount+"Bez"+$min)`;				$max=`min (ceil($val)) (size($curvePointHandles)-1)`;				$endBezier=`xform -q -ws -rp ("end"+$bezierCount+"Bez"+$max)`;				$endBezier=<< ((-$endBezier.x)), ((-$endBezier.y)), ((-$endBezier.z))>>;				$val=$val-(floor($val));				$hermitePoint=hermite($start, $end, ($startBezier-$start), ($endBezier+$end), $val);			}			setAttr ("bezier"+$bezierCount+"Control"+($x+1)+"Group.translateX") ($hermitePoint.x);			setAttr ("bezier"+$bezierCount+"Control"+($x+1)+"Group.translateY") ($hermitePoint.y);			setAttr ("bezier"+$bezierCount+"Control"+($x+1)+"Group.translateZ") ($hermitePoint.z);			move -a ($hermitePoint.x) ($hermitePoint.y) ($hermitePoint.z) ("bezier"+$bezierCount+"CurveBase.cv["+$x+"]");		}		select $curvePointHandles;}global proc updateBezierTube(int $bezerSystem){	global int $bezierCount;	vector $start;	vector $end;	vector $startBezier;	vector $endBezier;	string $controllers[];	vector $hermitePoint;	float $val;	float $min;	float $max;		$controllers=`ls -type "shape" ("bezier"+$bezierCount+"Control*")`;		$curvePointHandles=`ls -type "transform" ("bezierHandle"+$bezierCount+"Control*")`;		for($x=0; $x<(size($controllers)); ++$x){			$val=float($x*100);			$val=$val/(float(size($controllers)-1)/float(size($curvePointHandles)-1));			$val=($val/100);			if( (($val%1)==(0)) || (($val)>=(size($curvePointHandles))) ){				$hermitePoint=`xform -q -ws -rp ("bezierHandle"+$bezierCount+"Control"+($val+1))`;			}else{				$min=`min (floor($val)+1) (size($curvePointHandles))`;				$max=`min (ceil($val)+1) (size($curvePointHandles))`;				$start=`xform -q -ws -rp ("bezierHandle"+$bezierCount+"Control"+$min)`;					$end=`xform -q -ws -rp ("bezierHandle"+$bezierCount+"Control"+$max)`;				$min=`min (floor($val)+1) (size($curvePointHandles)-1)`;				$startBezier=`xform -q -ws -rp ("start"+$bezierCount+"Bez"+$min)`;				$max=`min (ceil($val)) (size($curvePointHandles)-1)`;				$endBezier=`xform -q -ws -rp ("end"+$bezierCount+"Bez"+$max)`;				$endBezier=<< ((-$endBezier.x)), ((-$endBezier.y)), ((-$endBezier.z))>>;				$val=$val-(floor($val));				$hermitePoint=hermite($start, $end, ($startBezier-$start), ($endBezier+$end), $val);			}			setAttr ("bezier"+$bezierCount+"Control"+($x+1)+".translateX") ($hermitePoint.x);			setAttr ("bezier"+$bezierCount+"Control"+($x+1)+".translateY") ($hermitePoint.y);			setAttr ("bezier"+$bezierCount+"Control"+($x+1)+".translateZ") ($hermitePoint.z);			move -a ($hermitePoint.x) ($hermitePoint.y) ($hermitePoint.z) ("bezier"+$bezierCount+"CurveBase.cv["+$x+"]");		}}