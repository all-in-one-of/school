import maya.cmds as cmdsimport random#erases anything on stage creates a new filecmds.file( f=True, new=True)#sets plaback timecmds.playbackOptions( minTime='0', maxTime='600' )#sets the angle of the cameracmds.setAttr('persp.translateX', 734.471)cmds.setAttr('persp.translateY', 91.372)cmds.setAttr('persp.translateZ', 44.949)#sets the rotation of the cameracmds.setAttr('persp.rotateX', 351.700)cmds.setAttr('persp.rotateY', 92.000)cmds.setAttr('persp.rotateZ', 360.000)#my list of ballsballs = ["a", "b", "c", "d", "e","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","a1", "b1", "c1", "d1", "e1","g1","h1","i1","j1","k1","l1","m1","n1","o1","p1","q1","r1","s1","t1","u1","v1","w1","x1","y1","z1"]g = -0.04shaders = [] shaderTypes = ['blinn','lambert','phong','phongE','anisotropic']'''LambertLambert is a flat material type that yields a smooth look without highlights. It calculates without taking into account surface reflectivity, which gives a matte, chalk-like appearance. Lambert material is ideal for surfaces that don't have highlights: pottery, chalk, matte paint, and so forth. By default, any newly created object gets the Lambert shader assigned to it. If the object should have highlights, though, it's a good idea to assign another shader. You'll want to see highlights even during the modeling stage, to see whether they are breaking across the model (indicating a seam in the surface).PhongThe Phong material type takes into account the surface curvature, amount of light, and camera angle to get accurate shading and highlights. The algorithm results in tight highlights that are excellent for polished shiny surfaces, such as plastic, porcelain, and glazed ceramic.TIPIf you notice that the highlights of a surface with a phong shader applied are exhibiting flickering in your animation, or you see a "ropy" appearance from line to line, switch to a Blinn material type, which has smoother highlights. This problem can also be made worse by bump mapping.PhongEPhongE is a faster rendering version of Phong that yields somewhat softer highlights than Phong. Most artists use regular Phong for objects with intense highlights and Blinn for everything else.BlinnThe Blinn material type calculates surfaces similarly to Phong, but the shape of the specular highlights in Blinn materials reflects light more accurately. Blinn is good for metallic surfaces with soft highlights, such as brass or aluminum. Because Blinn is a versatile material type and generally renders without problems, it's the primary material type we've used in these tutorials.AnisotropicThe Anisotropic material type stretches highlights and rotates them based on the viewer's relative position. Objects with many parallel micro-grooves, such as brushed metal, reflect light differently depending on how the grooves are aligned in relation to the viewer. Anisotropic materials are ideal for materials such as hair, feathers, brushed metal, and satin.'''st=len(shaderTypes)s=len(balls)/3for i in range(0,s);  oz =  random.randint(0,s)  ms =cmds.shadingNode(shaderTypes[oz], asShader=True)  shaders.append(ms)  for shader in shaders:  cmds.setAttr( shader +'.color',random.random(),random.random(),random.random(), type='double3')  i = 0.5 + (random.random()/2.0)   cmds.setAttr( shader +'.incandescence', 0, 0, i, type = 'double3')shaderSets = []for shader in shaders:  n=cmds.sets(renderable=True, noSurfaceShader=True, empty=True, name= shader + 'SG')  shaderSets.append(n)# shaderSet = cmds.sets(renderable=True, noSurfaceShader=True, empty=True, name= myShader + 'SG')# cmds.sets(forceElement=shaderSet, e=True)			#initial height and travelv0y = 2v0x = 1for ball in balls:        #This will be used for  the balls radius as well as the balls initial starting y        num = random.randrange(1,4)        	#randomly chooses the z for the ball        space = random.randint(0, 100)       	 # sets the x for the ball        move = random.randrange(0,100,15)        x=move        z=space        y=num/2        dx=1        	#creates the ball        cmds.sphere( name = ball, p=(x,y,z), radius = num )        for itr in xrange(0,1):                for tx in xrange(0,900):                        #creates the movement throught the y                        posy = y + v0y*(tx-1) + g*(tx-1)*(tx-1)/2                        #Makes sure the ball bounces when it hits its initial height                        if posy <= y + v0y*(1-1) + g*(1-1)*(1-1)/2:                                posy = y + v0y*(dx-1) + g*(dx-1)*(dx-1)/2                                dx+=1                                #This sets the ground limit for each ball so it continues to bounce to infinity                                if y + v0y*(dx-1) + g*(dx-1)*(dx-1)/2<= y + v0y*(1-1) + g*(1-1)*(1-1)/2:                                        dx=1                        #Creates the movement across the x                        posx = x + v0x*((itr*0) + tx-1)                        #this sets the keyframes based on tx                        cmds.setKeyframe( ball, attribute="translateY", value=posy, t= tx )                        cmds.setKeyframe( ball, attribute="translateX", value=posx, t= tx )        #these parameters slightly change how high, far and fast the next ball bounces        v0y+= .01        v0x+=.001        g+=-.001cmds.play()